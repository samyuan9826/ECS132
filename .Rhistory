k
b
k
b
b %*% b
b %*% b %*% b
k
k %*% k %*% k
k
j
k
k%*% k %*% k
k
k
h
h %*% h %*% h %*% h
hh
h
h
k
k %*% k %*% k
k
k[1,1] = 1
k[2,2] = 1
k[3,3] = 1
k
k %*% k %*% k
lll
b
h
for (i in 1:4){h[i,i] = 1}
h
h %*% h %*% h %*% h
h
ls
rm(list = ls())
a = matrix(c(0,1,))
a = matrix(c(0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0))
a
a = matrix(a, nrow = 4, ncol = 4)
a
for ( i in 2:5){print(i)}
source('hw2/Code2.R')
a
b = matrix_pow(a,4)
b
dim(b
)
dim(b)[1]
source('hw2/Code2.R')
a
b
c <- diag_fill(a)
c
a
c
a
c
a
c
a
c <- diag_fill(a)
c
dim(a)[1]
aa
a
a
source('hw2/Code2.R')
c <- diag_fill(a)
c
b
a
original_matrix = a
a
original_matrix
diag_matrix = diag_fill(original_matrix)
ans_o = matrix_pow(original_matrix, 4)
ans_d = matrix_pow(diag_matrix, 4)
ans_o
ans_d
ans_d
original_matrix
k <- original_matrix
k
k[k == 1]  = 4
k
k[k!= 0] = 1
k
original_matrix
source()
source('hw2/Code2.R')
ls
matrix_pow(diag_matrix)
matrix_pow(diag_matrix,4)
original_matrix
which(original_matrix == 1)
which(original_matrix == 1, arr.ind = TRUE)
original_matrix
which(original_matrix != 0, arr.ind = TRUE)
'sdfs'
stng <= 'sdfs'
stng <- 'sdfs'
stng
class(stng)
class(a)
class(a) == "matrix"
class(a) == "character"
a
adjMat = a
rm(list = ls())
a = matrix(c(0,1,0,1,0,1,0,1,0))
a
a = matrix(c(0,1,0,1,0,1,0,1,0), nrow = 3, ncol = 3)
a
adjM
adjMat <- a
idx = which(adjMat != 0, arr.ind = TRUE)
idx
nrow = dim(idx)[1]
nrow
sample(1:nrow)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
sample(1:nrow,1)
idx
idx[2]
idx[2,
]
idx = which(adjMat != 0, arr.ind = TRUE)
nrow = dim(idx)[1]
deleted_edge = sample(1:nrow,1) # Choose a random edge to be deleted
deleted_edge = idx[deleted_edge, ]
deleted_edge
idx
deleted_edge = sample(1:nrow,1) # Choose a random edge to be deleted
deleted_edge
deleted_edge = idx[deleted_edge, ]
deleted_edge
adjMat[deleted_edge]
adjMat
adjMat[deleted_edge[1], deleted_edge[2]]
deleted_edge
adjMat[deleted_edge[1], deleted_edge[2]] = adjMat[deleted_edge[1], deleted_edge[2]] - 1
adjMat
adjMat[deleted_edge[1], deleted_edge[2]] = adjMat[deleted_edge[1], deleted_edge[2]] + 1
adjMat
adjMat = diag_fill(adjMat)
source('hw2/Code2.R')
source('hw2/Code2.R')
source('hw2/Code2.R')
adjMat
adjMat = diag_fill(adjMat)
adjMat
connected_matrix = matrix_pow(adjMat, nrow)
connected_matrix
all(adjMat[lower.tri(adjMat)] == 0, m[upper.tri(m)] == 0)
m = adjMat
all(m[lower.tri(m)] == 0, m[upper.tri(m)] == 0)
adjMat
m = connected_matrix
all(m[lower.tri(m)] == 0, m[upper.tri(m)] == 0)
m
all(m[lower.tri(m)] != 0, m[upper.tri(m)] != 0)
m = adjMat
all(m[lower.tri(m)] != 0, m[upper.tri(m)] != 0)
m
m
d_test = read.csv('hw2/test.csv')
d_test
d_test = read.csv('hw2/test.csv', sep = ",")
d_test
d_test = read.csv('hw2/test.csv', sep = ";")
d_test
dim(d_test)
class(d_test)
as.matrix(d_test)
d_test = read.csv('hw2/test.csv', sep = ";", header = FALSE)
d_test
d_test
as.matrix(d_test)
data = as.matrix(d_test)
data
which(data == 1, arr.ind = TRUE)
data[2,1]
b = data[2,1]
b
b * 3
data = as.matrix(d_test)
data
data = as.matrix(d_test, dimnames = NULL)
data
names(data)
colnames(data)
colnames(data) = NULL
data
source('hw2/Code2.R')
a
ans <- simConn(10000, a)
ans
mean(b)
b
ans
mean(b)
mean(ans)
source('hw2/Code2.R')
ans <- simConn(1000, 'hw2/test.csv')
ans
rm(list = ls())
source('hw2/Test.R')
View(single_sim)
p = 0.6
q = 0.4
k = 5
sim_ans <- multi_sim(10000,p,q,k)
formula <- k*(1-(1-q)^k)+k*(1-p)-q*((1-(p*(1-q))^k)/(1-p*(1-q)))
part1 = k*(1-(1-q)^k)
part1
k*(1-p)
part1 = part1 + k*(1-p)
part1
part2 = (1-(p*(1-q))^k)/(1-p*(1-q))
part2
q * part2
part2 = q * part2
part1 - part2
multi_sim(10000,p,q,j)
multi_sim(10000,p,q,k)
k = 5
multi_sim(10000,p,q,k)
nreps = 100000
k = 5
sim_ans = multi_sim(nreps,p,q,k)
in_p = (1-q)*(1-(1-q)^k)/q
part1 = (1-p)*in_p
part2 = p*q*in_p
part3 = k - in_p
part1 + part2 +part3
sim_ans
part3
part1
part2
k = 10
in_p = (1-q)*(1-(1-q)^k)/q
part1 = (1-p)*in_p
part2 = p*q*in_p
part3 = k - in_p
part1+part2+part3
sim_ans = multi_sim(nreps,p,q,k)
sim_ans
d2 = read.csv('hw2/test.csv', header = FALSE, sep = ",")
d2
data = d2
data = as.matrix(data)
rownames(data) = NULL
colnames(data) = NULL
data
sim_ans = multi_sim(nreps,p,q,k)
sim_ans
k − (p/q)* (1 − q) + ( p/q − p)*(1 − q)^k
k-(p/q)* (1 − q) + ( p/q − p)*(1 − q)^k
k-(p/q)*(1− q)+(p/q− p)*(1−q)^k
k - (p/q)*(1-q)+(p/q-p)*(1-q)^k
k = 5
k - (p/q)*(1-q)+(p/q-p)*(1-q)^k
sim_ans = multi_sim(nreps,p,q,k)
sim_ans
p = 0.8
q= 0.2
sim_ans
sim_ans = multi_sim(nreps,p,q,k)
th_ans = k - (p/q)*(1-q)+(p/q-p)*(1-q)^k
sim_ans
th_ans
source('hw2/Code2.R')
b <- simConn(100000, 'hw2/test.csv')
b
toss <- function(){
if(runif(1)>=0.5){return("H")}
else{return("T")}
}
toss()
toss()
toss()
toss()
threeinrow<- function(ntimesteps){
consec <- 0
nwins <- 0
wintimes <- 0
startplay <- 0
for (i in 1:ntimesteps){
if(toss == 'H'){
consec <- consec + 1
if(consec == 3){
nwins <- nwins + 1
wintimes <- wintimes + i - startplay
consec <- 0
startplay <- i
}
}
else consec <- 0
}
return(wintimes/nwins)
}
threeinrow(10000000)
rm(list = ls(all.names = TRUE))
toss <- function(){
if(runif(1)>=0.5){return("H")}
else{return("T")}
}
b <- toss()
b
b == 'H'
source('markov_test.R')
threeinrow(100000)
threeinrow(1000000)
rm(list = ls(all.names = TRUE))
myFunc <- function(x){}
myFunc <- function(x){return(0.25*0.75^x)}
integrate(myFunc,1,2)
integrate(myFunc,2,6)
pgeom(2-1,0.25)
(pgeom(6-1,0.25) - pgeom(2-1,0.25))
integrate(myFunc,3,6)
getAnywhere(pgeom)
getAnywhere(C_pgeom)
m <- rbind(c(3,0.5),c(2,0.5))
m
m[1]
m[1,]
dim(m)
dim(m)[1]
m <- rbind(c(3,0.5),c(2,0.5), c(3,0.5))
m
dim(m[1])
dim(m)[1]
for (i in 1:3){print i}
for (i in 1:3){print i}
;
for (i in 1:200){}
for (i in 1:200){print(i)}
for (i in 1:3){print(i)}
rm(list = ls(all.names = TRUE))
source('hw3/Code3.R')
m <- rbind(c(3,0.5),c(2,0.5))
pmb(1,m)
dexp(1,0.2)
0.2*e^(-0.2*1)
e
exp
0.2*exo(-0.2*1)
0.2*exp(-0.2*1)
m
m <- rbind(c(3,0.5),c(2,0.5), c(5,0.6))
m
m[-1]
m[-1,:]
m[-1,]
m
m[-2,]
source('hw3/Code3.R')
pmb(1,m)
pmb(2,m)
m <- rbind(c(3,0.5),c(2,0.5))
pmb(2,m)
pmb(1,m)
pmb(4,m)
m
dmb(2,m)
m
m
m[-2,]
m[-1,]
m
nrow = dim(np)[1]
nrow = dim(m)[1]
nrow
nrow
1:nrow
np[-1,]
m[-1,]
m[-2,]
k <- m[-2,]
k
dim(k)
typeof(k)
k
k[1]
k[2]
as.matrix(k)
m
m <- rbind(c(3,0.5),c(2,0.5), c(3,0,6))
m <- rbind(c(3,0.5),c(2,0.5), c(3,0.6))
m
m[-2]
m[-2,]
k <- m[-2,]
dim(k)
k.dtype
type(k)
typeof(k)
class(k)
k
m <- m[-3,]
m
k <- m[-1,]
k
class(k)
class(m)
as.matrix(k)
class(k)
class(k) == "numeric"
k[1]
k[2]
k
m
source('hw3/Code3.R')
m
pmb(1,m)
source('hw3/Code3.R')
pmb(1,m)
dmb(1,m)
dmb(2,m)
m
dmb(4,m)
qbinom(1,3,0.5)
qbinom(2,3,0.5)
qbinom(1,2,0.5)
m
pmb(2,np)
pmb(2,m)
qbinom(2,2,0.5)
qbinom(0.375,2,0.5)
qbinom(0.375,3,0.5)
m
pmb(2,m)
qbinom(0.875,3,0.5)
qbinom(0.875,2,0.5)
m
m <- rbind(c(3,0.5),c(2,0.5), c(4,0.6), c(5,0.2))
m
pmb(1,np)
pmb(1,m)
ans <- pmb(1,m)
ans
m
qbinom(ans,3,0.5)
qbinom(ans,2,0.5)
qbinom(ans,4,0.6)
qbinom(ans,5,0.6)
m[4,2] = 1
m
pmb(1,m)
qbinom(0,3,0.5)
m[4,2] = 0.3
m
pmb(1.m)
pmb(1,m)
ans <- pmb(1,m)
qbinom(ans,3,0.5)
qbinom(ans,5,0.5)
qbinom(ans,4,0.6)
qbinom(ans,5,0.3)
m
myQbinom <- function(myQ,myX){
'
myQbinom: Find the qbinom given a vector in the format defined for the matrix np, i.e, first col = #Examples
second col = Success Prob
'
return(qbinom(myQ,myX[1],myX[2]))
}
apply(m,1,myQbinom,myQ = 0.375)
rm(list = ls(all.names = TRUE))
source('hw3/Code3.R')
m <- rbind(c(3,0.5),c(2,0.5))
pmb(1,m)
qmb(0.375,m)
pmb(2,m)
qmb(0.875,m)
pmb(02,m)
pmb(-2,m)
dmp(-2,m)
dmb(-2,m)
tmp <- runif(n)
tmp <- runif(3)
tmp
apply(tmp,1,max)
dim(tmp)
qmb(tmp,m)
tmp
qmb(0.4272888)
qmb(0.4272888,m)
qmb(0.1350656,m)
qmb(0.5604273,m)
tmp <- runif(n)
tmp <- runif(6)
dim(tmp)
class(tmp)
b <- as.matrix(tmp)
b
dim(b)
apply(b,1,qmb, np = m)
source('hw3/Code3.R')
rmb(10,m)
